
-- Variables and Mutability
-- Type Mutability Name = Value
int immutable = 10
int mut mutable = 20
mutable = 10

-- Common Types
int, float, boolean, string

println(typeof(10) == int) -- true
println(sizeof(10))

int x = 10.5 as float -- 10
int y = 10.5.round(0) -- 11
float z = 10.227323.round(2) -- 10.23

-- Functions
void sayHello() {
    -- functions that only take in one parameter can be written without parentheses
    echo "Hello, World!"
}

void sayMyName(string name) {
    echo "Hello, $name"
}

void <T use Add> add(T x, T y) {
    out x + y
}

-- Control Flow
if (typeof(10.34) == float) {
    echo("Yep, the language works fine!")
}
else {
    echo("You entered the Matrix...")
}

when ([10, 20, 30, 40].contains?(30)) {
    true -> echo "Yey"
    false -> echo "Ney"
}

int x = 10

if (x == 10) echo "x is 10"
elif (x == 15) echo "x is 15"
else echo "x is something else"

while (x == 10) {
    echo "hihi"
}

for (i in 0..10) {
    echo "$i"
}

for (0..10) {
    echo "looping..."
}

for {
    echo "looping forever"
    if (x != 0) break 
}

-- Entities
entity User init(string username, string email) {
    boolean mut isActive = true
    String mut username = new String(username)
    String mut email = new String(email)
    int mut signInCount = 1

    init::fromEmail(string email) {
        this.email = new String(email)
        this.username = new String(username)
    }

    void login() {
        this.signInCount += 1
        this.isActive = true
    }

    void logout() {
        this.isActive = false
    }
}

void main() {
    set user = new User("someone123", "someone@example.com")
    user.logout()

    set otherUser = new User::fromEmail("someone@example.com")
    user.login()
}

-- enums
enum Day {
    Monday, Tuesday, Wednesday, Thursday, Friday,
    Weekend(String),

    init::weekend(string<"Sunday","Saturday"> day) {
        out this::Weekend(day) catch (day) {
            throw new IllegalStateError("Weekend Day must be 'Sunday' or 'Saturday'.")
        }
    }
}

void main() {
    set weekday = Day::Tuesday
    set weekend = Day::weekend("Sunday")
}

-- common collections
int[] mut ints = [10, 20, 30, 40, 50]
ints.add(60)

HashMap<string, int> mut map = new HashMap()
map.entry("a", 1)
map.entry("b", 2)

int one = map.get("a")
int two = map.get("b")

-- Error Handling

Option<int> mut value = Value(10)
Option<int> mut null = Null

if (value == Value(10)) echo "Hello, World!"
if (null == Null) echo "Hello, Moon!"

int newValue = value.try -- 10
int newValue = null.or(0) -- 0

if (null.isNull()) {
    throw new NullError("value of 'null' is Null.")
}

null.try -- "Error: Called 'try' on a Null-Value!"

-- Results

Result<int, IllegalStateError> mut value = Success(10)
Result<int, IllegalStateError> mut error = Error(new IllegalStateError("no value."))

int x = value.try -- 10
int y = error.try -- "Error: no value."

Result<int> mut value = Error
int x = value.try -- "Err: called 'try' on an Error-Value!"

-- traits and entities

trait GameObject {
    pub (int, int) mut position = (0, 0)
}

trait Collider {
    -- trait(Collider, GameObject)[] is an array that takes in all entities that implement Collider and GameObject
    priv trait(Collider, GameObject)[] mut collideableEntities

    init(trait(Collider, GameObject)[] collideableEntities) {
        this.collideableEntities = collideableEntities
    }

    void checkForCollision() {
        for (entity_ in this.collideableEntities) {
            if (parent.position == entity_.position) {
                this.onCollision(entity_)
            }
        }       
    }

    open void onCollision(trait(Collider, GameObject) other)
}

entity Block use GameObject with Collider {
    priv boolean hasCollided = false

    override void onCollision(trait(Collider, GameObject) other) {
        if (other.trait?(PlayerController)) {
            if (this.trait?(LuckyBlock)) {
                Entity mut player = Main.player
                player.points += 5
                this.hasCollided = true
            }
        }
    }
}

scene Main {
    pub Entity mut player

    init {
        ...
    }
}

-- Scenes
-- A Scene or "Region" is a part of your code, which shares global values and functions.

scene Main {
    void main() {
        echo "Hello, World!"
    }
}

scene A {
    pub void foo() {
        echo "Foo!"
    }
}

scene B {
    void fooBar() {
        A::foo()
        echo "Bar!"
    }
}

-- Capture Types

entity Array<T> {
    -- ...
}

entity IntArray {
    priv Array<int> mut values
    -- ...
}

entity NumberArray {
    -- can be either Array<int> or Array<float>
    priv Array<int, float> mut values
}

String<"Harold", "David"> name = "Thomas" -- Error: name has to be either "Harold" or "David"  

